PARSER_BEGIN(BibTeX)

package compilador;
import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.io.IOException;
import java.io.FileInputStream;
import java.util.Scanner;
import elementos.*;

public class BibTeX {

	private static HashMap < String, HashMap < String, String > > symbolTable = new HashMap < String, HashMap < String, String >> ();
	private static HashMap < String, Entry > entradas = new HashMap < String, Entry > ();

	private static Entry entradaRecente = null;
	private static SimpleNode simpleN;
	private static String entryReading = null;
	private static int lastGoodLine = 0;
	
public static void main(String args[]) throws ParseException, IOException {

		String fname = "";
		Scanner sc = new Scanner(System. in );
		while (fileExist(fname) != true) {
			System.out.print("Introduza o ficheiro que pretende usar > ");
			fname = sc.nextLine();
			System.out.print("\n\n\n\n");
		}

		BibTeX parser = new BibTeX(new FileInputStream(new File(fname)));
		simpleN = parser.start();

		//simpleN.dump("");
		semanticAnalysis();
		sc.close();
	}

	private static boolean fileExist(String filename) {
		File file = new File(filename);
		return file.exists();
	}
}

PARSER_END(BibTeX)

SKIP: {
	" " | "\r" | "\t" | "\n"
}

TOKEN: // 1st level (entries)
{ < ARTICLE: "@article" > | < BOOK: "@book" > | < BOOKLET: "@booklet" > | < CONFERENCE: "@conference" > | < INBOOK: "@inbook" > | < INCOLLECTION: "@incollection" > | < INPROCEEDINGS: "@inproceedings" > | < MANUAL: "@manual" > | < MASTERSTHESIS: "@mastersthesis" > | < MISC: "@misc" > | < PHDTHESIS: "@phdthesis" > | < PROCEEDINGS: "@proceedings" > | < TECHREPORT: "@techreport" > | < UNPUBLISHED: "@unpublished" >
}

TOKEN: // 2nd level [fields]
{ < AUTHOR: "author" > | < TITLE: "title" > | < JOURNAL: "journal" > | < YEAR: "year" > | < VOLUME: "volume" > | < NUMBER: "number" > | < PAGES: "pages" > | < MONTH: "month" > | < NOTE: "note" > | < KEY: "key" > | < EDITOR: "editor" > | < PUBLISHER: "publisher" > | < SERIES: "series" > | < ADDRESS: "address" > | < EDITION: "edition" > | < HOWPUBLISHED: "howpublished" > | < CHAPTER: "chapter" > | < TYPE: "type" > | < BOOKTITLE: "booktitle" > | < ORGANIZATION: "organization" > | < SCHOOL: "school" > | < INSTITUTION: "institution" >
}

TOKEN: { < FIELD: "\"" ( < WORD > | " ") + "\"" > | < WORD: ( < CHARACTER > | < INTEGER > ) + > | < CHARACTER: ["A" - "Z", "a" - "z"] > | < INTEGER: ["0" - "9"] > | < OPENBRACES: "{" > | < CLOSEBRACES: "}" > | < COMMA: "," > | < EQUALS: "=" >
}

void imprimirSymbolTable(): {} {
	{
		System.out.println("### TABELA DE SIMBOLOS ###");
		for (HashMap.Entry < String, HashMap < String, String >> entry: symbolTable.entrySet()) {
			String onKey = entry.getKey();
			for (HashMap.Entry < String, String > entrada: entry.getValue().entrySet()) {
				System.out.println("Key = " + onKey + "|| " + "Entry = " + entrada.getKey() + ", Value = " + entry.getValue().get(entrada.getKey()));
			}
		}
	}
}

SimpleNode start(): {Token t1;}
{
	(
	(
	t1 = < ARTICLE > | t1 = < BOOK > | t1 = < BOOKLET > | t1 = < CONFERENCE > | t1 = < INBOOK > | t1 = < INCOLLECTION > | t1 = < INPROCEEDINGS > | t1 = < MANUAL > | t1 = < MASTERSTHESIS > | t1 = < MISC > | t1 = < PHDTHESIS > | t1 = < PROCEEDINGS > | t1 = < TECHREPORT > | t1 = < UNPUBLISHED > ) {
		entryReading = t1.image;
		switch (entryReading) {
			case "@article":
				entradaRecente = new Article();
				break;
			case "@book":
				entradaRecente = new Book();
				break;
			case "@booklet":
				entradaRecente = new Booklet();
				break;
			case "@conference":
				entradaRecente = new Conference();
				break;
			case "@inbook":
				entradaRecente = new Inbook();
				break;
			case "@incollection":
				entradaRecente = new Incollection();
				break;
			case "@inproceedings":
				entradaRecente = new Inproceedings();
				break;
			case "@manual":
				entradaRecente = new Manual();
				break;
			case "@mastersthesis":
				entradaRecente = new Mastersthesis();
				break;
			case "@misc":
				entradaRecente = new Misc();
				break;
			case "@phdthesis":
				entradaRecente = new Phdthesis();
				break;
			case "@proceedings":
				entradaRecente = new Proceedings();
				break;
			case "@techreport":
				entradaRecente = new Techreport();
				break;
			case "@unpublished":
				entradaRecente = new Unpublished();
				break;
		}
	} < OPENBRACES > data() < CLOSEBRACES > ) + < EOF > {
		//jjtThis.jjtSetValue(t1.image);
		//System.out.println(jjtThis.jjtGetValue());
		return jjtThis;
	}
}

void data(): {Token t1 = null;}
{
	(t1 = < WORD > ) {
		entradas.put(t1.image, entradaRecente);
		symbolTable.put(t1.image, new HashMap < String, String > ());
		entryReading = t1.image;
		lastGoodLine = t1.endLine;
		jjtThis.jjtSetValue(t1.image);
		//System.out.println(jjtThis.jjtGetValue());
	} < COMMA > // TODO: Alterar
	(t1 = atribute()  < COMMA > ) *
}

Token atribute(): {Token t1 = null;}
{
	(t1 = < AUTHOR > | t1 = < TITLE > | t1 = < JOURNAL > |
	 t1 = < YEAR > | t1 = < VOLUME > | t1 = < NUMBER > |
	 t1 = < PAGES > | t1 = < MONTH > | t1 = < NOTE > |
	 t1 = < KEY > | t1 = < EDITOR > | t1 = < PUBLISHER > |
	 t1 = < SERIES > | t1 = < ADDRESS > | t1 = < EDITION > |
	 t1 = < HOWPUBLISHED > | t1 = < CHAPTER > | t1 = < TYPE > |
	 t1 = < BOOKTITLE > | t1 = < ORGANIZATION > | t1 = < SCHOOL > |
	 t1 = < INSTITUTION > )
	definition(t1) {
	  	jjtThis.jjtSetValue(t1.image);
		//System.out.println(" " + jjtThis.jjtGetValue());
		return t1;
	}
}

Token definition(Token attr): {Token field = null;}
 {
 	  < EQUALS > (field = < FIELD > ) ?
 		{
			{
				try {
					if (field == null) throw new ParsingError("[WARNING] Variavel sem valor declarado na linha " + lastGoodLine);
					else {
						jjtThis.jjtSetValue(field.image);
						if (symbolTable.get(entryReading).get(attr.image) == null) {
							lastGoodLine = field.endLine;
							symbolTable.get(entryReading).put(attr.image, field.image);
						} else throw new ParsingError("[WARNING] A referência " + entryReading + " tem o campo \'" + attr.image + "\' repetido na linha " + field.beginLine);
					}
				} catch (ParsingError e) {
					System.out.println(e.getMessage());
				}
			}
			return field;
	}
}

void semanticAnalysis():{}{
  {
    for(int i = 0; i < simpleN.jjtGetNumChildren(); i++)    {		SimpleNode temp = (SimpleNode) simpleN.jjtGetChild(i);
		System.out.println(temp.jjtGetValue());
		System.out.println(temp.jjtGetNumChildren());
    }
    SimpleNode temp = (SimpleNode) simpleN.jjtGetChild(0);  }}

/*
void semanticAnalysis() :{}
{
	{
	for (HashMap.Entry<String, HashMap<String, String >> entry : symbolTable.entrySet()) {
        	String onKey = entry.getKey();
        	switch(onKey)
        	{
        	  case "@article":
        	  	article(entry.getValue());
        	  	break;
        	  case "@book":
        	  	book(entry.getValue());
        	  	break;
        	  case "@booklet":
        	  	booklet(entry.getValue());
        	  	break;
        	  case "@conference":
        	  	conference(entry.getValue());
        	  	break;
        	  case "@inbook":
        	  	inbook(entry.getValue());
        	  	break;
        	  case "@incollection":
        	  	incollection(entry.getValue());
        	  	break;
        	  case "@inproceedings":
        	  	inproceedings(entry.getValue());
        	  	break;
        	  case "@manual":
        	  	manual(entry.getValue());
        	  	break;
        	  case "@mastersthesis":
        	  	mastersthesis(entry.getValue());
        	  	break;
        	  case "@misc":
        	  	misc(entry.getValue());
        	  	break;
        	  case "@phdthesis":
        	  	phdthesis(entry.getValue());
        	  	break;
        	  case "@proceedings":
        	  	proceedings(entry.getValue());
        	  	break;
        	  case "@techreport":
        	  	techreport(entry.getValue());
        	  	break;
        	  case "@unpublished":
        	  	unpublished(entry.getValue());
        	  	break;
        	}
      }
    }
}

void article(HashMap<String, String > dados) : {}
{
	{
	  try {
	    String reference = dados.get("reference"), author = dados.get("author"), title = dados.get("title"), journal = dados.get("journal"), year = dados.get("year");

		if(reference == null || author == null || title == null || journal == null || year == null) throw new ParsingError("[@article] : Estes campos são obrigatórios: author, title, journal, year.");
		else {
		  Article novoArtigo = new Article(reference, author, title, journal, year);
		  for (HashMap.Entry<String, String > entry : dados.entrySet()) {
		    if (entry.getKey() == "reference" || entry.getKey() == "author" || entry.getKey() == "title" || entry.getKey() == "journal" || entry.getKey() == "year"){}
		    else{
		    switch(entry.getKey())
		    {
		      case "volume":
		      	novoArtigo.setVolume(entry.getValue());
		      	break;
		      case "number":
		      	novoArtigo.setNumber(entry.getValue());
		      	break;
		      case "pages":
		      	novoArtigo.setPages(entry.getValue());
		      	break;
		      case "month":
		      	novoArtigo.setMonth(entry.getValue());
		      	break;
		      case "note":
		      	novoArtigo.setNote(entry.getValue());
		      	break;
		      case "key":
		      	novoArtigo.setKey(entry.getValue());
		      	break;
		      default:
		      	throw new ParsingError("[@article] " + entry.getKey() + " não é um campo válido.");
		      	break;
		    }
		  }
		  }
		  entradas.get("article").add(novoArtigo);
		}
	  } catch (ParsingError e)
	  {
	    System.out.println(e.getMessage());
	  }
  	}
}

void book(HashMap<String, String > dados) : {}
{
	
    {
      try {
         String reference = dados.get("reference"), author = dados.get("author"), editor = dados.get("editor"), title = dados.get("title"), publisher = dados.get("publisher"), year = dados.get("year");
		if(reference == null || !(author == null ^ editor == null) || title == null || publisher == null || year == null) throw new ParsingError("[@book] : Estes campos são obrigatórios: author/editor, title, publisher, year.");
		else {

		  Book newBook;
		  if (author != null)
		  {
		    newBook = new Book(reference, "author", author, title, publisher, year);
		  }
		  else
		  {
		    newBook = new Book(reference, "editor", editor, title, publisher, year);

		  }
		
		      if(dados.get("volume") != null && dados.get("number") != null)
		      {throw new ParsingError("[@book] Volume e number nao podem existir simultaneamente.");}
		      else
		  {
		    
		  
		  for (HashMap.Entry<String, String > entry : dados.entrySet()) {
		    if (entry.getKey() == "reference" || entry.getKey() == "author" || entry.getKey() == "editor" || entry.getKey() == "title" || entry.getKey() == "publisher" || entry.getKey() == "year"){}
		    else{
		        
		    switch(entry.getKey())
		    {
		      case "volume":
		      	newBook.setVolume(entry.getValue());
		      	break;
		      case "number":
		      	newBook.setNumber(entry.getValue());
		      	break;
		      case "series":
		      	newBook.setSeries(entry.getValue());
		      	break;
		      case "address":
		      	newBook.setAddress(entry.getValue());
		      	break;
		      case "edition":
		      	newBook.setEdition(entry.getValue());
		      	break;
		      case "month":
		      	newBook.setMonth(entry.getValue());
		      	break;
		      	case "note":
		      	newBook.setNote(entry.getValue());
		      	break;
		      	case "key":
		      	newBook.setKey(entry.getValue());
		      	break;
		      default:
		      	throw new ParsingError("[@book] " + entry.getKey() + " não é um campo válido.");
		      	break;
		    }
		  
		  
		   }
		}
		  entradas.get("book").add(newBook);

       
      }


	  }
	}
	 catch (ParsingError e) {
	    System.out.println(e.getMessage());
	  }
  	}
}

void booklet(HashMap<String, String > dados) :{}
{
  {
	  try {
	    String reference = dados.get("reference"), title = dados.get("title");

		if(reference == null || title == null) throw new ParsingError("[@booklet] : Este campo é obrigatório:  title.");
		else {
		  Booklet newBooklet = new Booklet(reference, title);
		  for (HashMap.Entry<String, String > entry : dados.entrySet()) {
		    if (entry.getKey() == "reference" || entry.getKey() == "title"){}
		    else{
		    switch(entry.getKey())
		    {
		      case "author":
		      	newBooklet.setAuthor(entry.getValue());
		      	break;
		      case "howpublished":
		      	newBooklet.setHowPublished(entry.getValue());
		      	break;
		      case "address":
		      	newBooklet.setAddress(entry.getValue());
		      	break;
		      case "month":
		      	newBooklet.setMonth(entry.getValue());
		      	break;
		      case "year":
		      	newBooklet.setYear(entry.getValue());
		      	break;
		      case "note":
		      	newBooklet.setNote(entry.getValue());
		      	break;
		      case "key":
		      	newBooklet.setKey(entry.getValue());
		      	break;
		      default:
		      	throw new ParsingError("[@booklet] " + entry.getKey() + " não é um campo válido.");
		      	break;
		    }
		  }
		  }
		  entradas.get("booklet").add(newBooklet);
		}
	  } catch (ParsingError e)
	  {
	    System.out.println(e.getMessage());
	  }
  	}
}

void conference(HashMap<String, String > dados) : {}
{
	{
	 try {
	   	String reference = dados.get("reference"), author = dados.get("author"), title = dados.get("title"), bookTitle = dados.get("booktitle"), year = dados.get("year");
	   	if (reference == null || author == null || title == null || bookTitle == null || year == null) throw new ParsingError("[@conference] : Estes campos são obrigatórios: reference, author, title, booktitle.");
		Conference novaConference = new Conference(reference, author, title, bookTitle, year);
		int checkingTwoParams = 2;
		  for (HashMap.Entry<String, String > entry : dados.entrySet()) {
		    if (entry.getKey() == "reference" || entry.getKey() == "author" || entry.getKey() == "title" || entry.getKey() == "booktitle" || entry.getKey() == "year"){}
		    else{
		    switch(entry.getKey())
		    {
		      case "editor":
		      	novaConference.setEditor(entry.getValue());
		      	break;
		      case "volume":
		      	checkingTwoParams--;
		      	novaConference.setVolume(entry.getValue());
		      	break;
		      case "number":
		      	checkingTwoParams--;
		      	novaConference.setNumber(entry.getValue());
		      	break;
		      case "series":
		      	novaConference.setSeries(entry.getValue());
		      	break;
		      case "pages":
		      	novaConference.setPages(entry.getValue());
		      	break;
		      case "address":
		      	novaConference.setAddress(entry.getValue());
		      	break;
		      case "month":
		      	novaConference.setMonth(entry.getValue());
		      	break;
		      case "organization":
		      	novaConference.setOrganization(entry.getValue());
		      	break;
		      case "publisher":
		      	novaConference.setPublisher(entry.getValue());
		      	break;
		      case "note":
		      	novaConference.setNote(entry.getValue());
		      	break;
		      case "key":
		      	novaConference.setKey(entry.getValue());
		      	break;
		      default:
		      	throw new ParsingError("[@conference] " + entry.getKey() + " não é um campo válido.");
		      	break;
		    }
		  }
		}
		entradas.get("conference").add(novaConference);
		if (checkingTwoParams == 0) throw new ParsingError("[@conference] Volume e Number não podem coexistir");
	  } catch (ParsingError e) {
	    System.out.println(e.getMessage());
	  }
	}
}

void misc(HashMap<String, String > dados) : {}
{
	{
	  try {
	   	String reference = dados.get("reference");
        
		Misc novoMisc = new Misc(reference);

		 for (HashMap.Entry<String, String > entry : dados.entrySet()) {
		   if (entry.getKey() == "reference") continue;
		    switch(entry.getKey())
		    {
		      case "author":
		      	novoMisc.setAuthor(entry.getValue());
		      	break;
		      case "title":
		      	novoMisc.setTitle(entry.getValue());
		      	break;
		      case "howpublished":
		      	novoMisc.setHowpublished(entry.getValue());
		      	break;
		      case "month":
		      	novoMisc.setMonth(entry.getValue());
		      	break;
		      case "year":
		      	novoMisc.setYear(entry.getValue());
		      	break;
		      case "note":
		      	novoMisc.setNote(entry.getValue());
		      	break;
		      case "key":
		      	novoMisc.setKey(entry.getValue());
		      	break;
		      default:
		      	throw new ParsingError("[@misc] " + entry.getKey() + " não é um campo válido.");
		      	break;
		    }
		  }
		  entradas.get("misc").add(novoMisc);
	  } catch (ParsingError e)
	  {
	    System.out.println(e.getMessage());
	  }
	}
}

void phdthesis(HashMap<String, String > dados) : {}
{
	{
	  try {
	    String reference = dados.get("reference"), author = dados.get("author"), title = dados.get("title"), school = dados.get("school"), year = dados.get("year");

		if(reference == null || author == null || title == null || school == null || year == null) throw new ParsingError("[@phdthesis] : Estes campos são obrigatórios: author, title, school, year.");
		else {
		  Phdthesis novoPhd = new Phdthesis(reference, author, title, school, year);
		  for (HashMap.Entry<String, String > entry : dados.entrySet()) {
		    if (entry.getKey() == "reference" || entry.getKey() == "author" || entry.getKey() == "title" || entry.getKey() == "school" || entry.getKey() == "year"){}
		    else{
		    switch(entry.getKey())
		    {
		      case "type":
		      	novoPhd.setType(entry.getValue());
		      	break;
		      case "address":
		      	novoPhd.setAddress(entry.getValue());
		      	break;
		      case "month":
		      	novoPhd.setMonth(entry.getValue());
		      	break;
		      case "note":
		      	novoPhd.setNote(entry.getValue());
		      	break;
		      case "key":
		      	novoPhd.setKey(entry.getValue());
		      	break;
		      default:
		      	throw new ParsingError("[@phdthesis] " + entry.getKey() + " não é um campo válido.");
		      	break;
		    }
		  }
		  }
		  entradas.get("phdthesis").add(novoPhd);
		}
	  } catch (ParsingError e)
	  {
	    System.out.println(e.getMessage());
	  }
  	}
}

void proceedings(HashMap<String, String > dados) : {}
{
	{
	  try {
	    String reference = dados.get("reference"), title = dados.get("title"), year = dados.get("year");

		if(reference == null || title == null || year == null) throw new ParsingError("[@proceedings] : Estes campos são obrigatórios: title, year.");
		else {
		  Proceedings novoProceeding = new Proceedings(reference, title, year);
		  for (HashMap.Entry<String, String > entry : dados.entrySet()) {
		    if (entry.getKey() == "reference" || entry.getKey() == "title" || entry.getKey() == "year"){}
		    else{
		    switch(entry.getKey())
		    {
		      case "editor":
		      	novoProceeding.setEditor(entry.getValue());
		      	break;
		      case "volume":
		      	novoProceeding.setVolume(entry.getValue());
		      	break;
		      case "number":
		      	novoProceeding.setNumber(entry.getValue());
		      	break;
		      case "series":
		      	novoProceeding.setSeries(entry.getValue());
		      	break;
		      case "address":
		      	novoProceeding.setAddress(entry.getValue());
		      	break;
		      case "month":
		      	novoProceeding.setMonth(entry.getValue());
		      	break;
		      case "publisher":
		      	novoProceeding.setPublisher(entry.getValue());
		      	break;
		      case "organization":
		      	novoProceeding.setOrganization(entry.getValue());
		      	break;
		      case "note":
		      	novoProceeding.setNote(entry.getValue());
		      	break;
		      case "key":
		      	novoProceeding.setKey(entry.getValue());
		      	break;
		      default:
		      	throw new ParsingError("[@proceedings] " + entry.getKey() + " não é um campo válido.");
		      	break;
		    }
		  }
		  }
		  entradas.get("proceedings").add(novoProceeding);
		}
	  } catch (ParsingError e)
	  {
	    System.out.println(e.getMessage());
	  }
  	}
}

void techreport(HashMap<String, String > dados) : {}
{
	{
	  try {
	    String reference = dados.get("reference"), author = dados.get("author"), title = dados.get("title"), institution = dados.get("institution"), year = dados.get("year");

		if(reference == null || author == null || title == null || institution == null || year == null) throw new ParsingError("[@techreport] : Estes campos são obrigatórios: author, title, institution, year.");
		else {
		  Techreport novoTechreport = new Techreport(reference, author, title, institution, year);
		  for (HashMap.Entry<String, String > entry : dados.entrySet()) {
		    if (entry.getKey() == "reference" || entry.getKey() == "author" || entry.getKey() == "title" || entry.getKey() == "institution" || entry.getKey() == "year"){}
		    else{
		    switch(entry.getKey())
		    {
		      case "type":
		      	novoTechreport.setType(entry.getValue());
		      	break;
		      case "number":
		      	novoTechreport.setNumber(entry.getValue());
		      	break;
		      case "address":
		      	novoTechreport.setAddress(entry.getValue());
		      	break;
		      case "month":
		      	novoTechreport.setMonth(entry.getValue());
		      	break;
		      case "note":
		      	novoTechreport.setNote(entry.getValue());
		      	break;
		      case "key":
		      	novoTechreport.setKey(entry.getValue());
		      	break;
		      default:
		      	throw new ParsingError("[@techreport] " + entry.getKey() + " não é um campo válido.");
		      	break;
		    }
		  }
		  }
		  entradas.get("techreport").add(novoTechreport);
		}	
	  } catch (ParsingError e)
	  {
	    System.out.println(e.getMessage());
	  }
  	}
}

void unpublished(HashMap<String, String > dados) : {}
{
	{
	  try {
	    String reference = dados.get("reference"), author = dados.get("author"), title = dados.get("title"), note = dados.get("note");

		if(reference == null || author == null || title == null || note == null) throw new ParsingError("[@unpublished] : Estes campos são obrigatórios: author, title, note.");
		else {
		  Unpublished novoUnpublished = new Unpublished(reference, author, title, note);
		  for (HashMap.Entry<String, String > entry : dados.entrySet()) {
		    if (entry.getKey() == "reference" || entry.getKey() == "author" || entry.getKey() == "title" || entry.getKey() == "note"){}
		    else{
		    switch(entry.getKey())
		    {
		      case "month":
		      	novoUnpublished.setMonth(entry.getValue());
		      	break;
		      case "year":
		      	novoUnpublished.setYear(entry.getValue());
		      	break;
		      case "key":
		      	novoUnpublished.setKey(entry.getValue());
		      	break;
		      default:
		      	throw new ParsingError("[@unpublished] " + entry.getKey() + " não é um campo válido.");
		      	break;
		    }
		  }
		  }
		  entradas.get("unpublished").add(novoUnpublished);
		}	
	  } catch (ParsingError e)
	  {
	    System.out.println(e.getMessage());
	  }
  	}
}

void inbook(HashMap<String, String > dados) : {}
{
	{
		try {
		    String reference = dados.get("reference"), author = dados.get("author"), editor = dados.get("editor"), title = dados.get("title"), chapter = dados.get("chapter"), pages = dados.get("pages"), publisher = dados.get("publisher"), year = dados.get("year"), volume = dados.get("volume"), number = dados.get("number");
	
			if (!(author == null ^ editor == null) || title == null || !(chapter == null ^ pages == null) || publisher == null || year == null) throw new ParsingError("[@inbook] : Estes campos são obrigatórios: author/editor, title, chapter/pages, publisher, year.");
			else if (volume != null && number != null) throw new ParsingError("[@inbook] : Os campos \"volume\" e \"number\" não podem estar simultaneamente presentes.");
			else {
				Inbook newInbook = new Inbook(reference, (author != null ? "author" : "editor"), (author != null ? author : editor), title, "chapter", chapter, publisher, year);
				
				for (HashMap.Entry<String, String> entry : dados.entrySet()) {
					if (entry.getKey().equals("reference") || entry.getKey().equals("author") || entry.getKey().equals("editor") || entry.getKey().equals("title") || entry.getKey().equals("chapter") || entry.getKey().equals("pages") || entry.getKey().equals("publisher") || entry.getKey().equals("year")) continue;
					else {
						switch (entry.getKey()) {
							case "volume":
								newInbook.setVolume(entry.getValue());
								break;
							case "number":
								newInbook.setNumber(entry.getValue());
								break;
							case "series":
								newInbook.setSeries(entry.getValue());
								break;
							case "type":
								newInbook.setType(entry.getValue());
								break;
							case "address":
								newInbook.setAddress(entry.getValue());
								break;
							case "edition":
								newInbook.setEdition(entry.getValue());
								break;
							case "month":
								newInbook.setMonth(entry.getValue());
								break;
							case "note":
								newInbook.setNote(entry.getValue());
								break;
							case "key":
								newInbook.setKey(entry.getValue());
								break;
							default:
								throw new ParsingError("[@inbook] " + entry.getKey() + " não é um campo válido.");
						}
					}
				}
				
				entradas.get("inbook").add(newInbook);
			}
		} catch (ParsingError e) {
			System.out.println(e.getMessage());
	    }
	}
}

void incollection(HashMap<String, String> dados) : {}
{
	{
		try {
		    String reference = dados.get("reference"), author = dados.get("author"), title = dados.get("title"), booktitle = dados.get("booktitle"), publisher = dados.get("publisher"), year = dados.get("year"), volume = dados.get("volume"), number = dados.get("number");
	
			if (author == null | title == null | booktitle == null || publisher == null || year == null) throw new ParsingError("[@incollection] : Estes campos são obrigatórios: author, title, booktitle, publisher, year.");
			else if (volume != null && number != null) throw new ParsingError("[@incollection] : Os campos \"volume\" e \"number\" não podem estar simultaneamente presentes.");
			else {
				Incollection newIncollection = new Incollection(reference, author, title, booktitle, publisher, year);
				
				for (HashMap.Entry<String, String> entry : dados.entrySet()) {
					if (entry.getKey().equals("reference") || entry.getKey().equals("author") || entry.getKey().equals("title") || entry.getKey().equals("booktitle") || entry.getKey().equals("publisher") || entry.getKey().equals("year")) continue;
					else {
						switch (entry.getKey()) {
							case "editor":
								newIncollection.setEditor(entry.getValue());
								break;
							case "volume":
								newIncollection.setVolume(entry.getValue());
								break;
							case "number":
								newIncollection.setNumber(entry.getValue());
								break;
							case "series":
								newIncollection.setSeries(entry.getValue());
								break;
							case "type":
								newIncollection.setType(entry.getValue());
								break;
							case "chapter":
								newIncollection.setChapter(entry.getValue());
								break;
							case "pages":
								newIncollection.setPages(entry.getValue());
								break;
							case "address":
								newIncollection.setAddress(entry.getValue());
								break;
							case "edition":
								newIncollection.setEdition(entry.getValue());
								break;
							case "month":
								newIncollection.setMonth(entry.getValue());
								break;
							case "note":
								newIncollection.setNote(entry.getValue());
								break;
							case "key":
								newIncollection.setKey(entry.getValue());
								break;
							default:
								throw new ParsingError("[@incollection] " + entry.getKey() + " não é um campo válido.");
						}
					}
				}
				
				entradas.get("incollection").add(newIncollection);
			}
		} catch (ParsingError e) {
			System.out.println(e.getMessage());
	    }
	}
}

void inproceedings(HashMap<String, String > dados) : {}
{
	{
	 try {
	   	String reference = dados.get("reference"), author = dados.get("author"), title = dados.get("title"), bookTitle = dados.get("booktitle"), year = dados.get("year");
	   	if (reference == null || author == null || title == null || bookTitle == null || year == null) throw new ParsingError("[@inproceedings] : Estes campos são obrigatórios: reference, author, title, booktitle.");
		Inproceedings newInproceedings = new Inproceedings(reference, author, title, bookTitle, year);
		int checkingTwoParams = 2;
		  for (HashMap.Entry<String, String > entry : dados.entrySet()) {
		    if (entry.getKey() == "reference" || entry.getKey() == "author" || entry.getKey() == "title" || entry.getKey() == "booktitle" || entry.getKey() == "year"){}
		    else{
		    switch(entry.getKey())
		    {
		      case "editor":
		      	newInproceedings.setEditor(entry.getValue());
		      	break;
		      case "volume":
		      	checkingTwoParams--;
		      	newInproceedings.setVolume(entry.getValue());
		      	break;
		      case "number":
		      	checkingTwoParams--;
		      	newInproceedings.setNumber(entry.getValue());
		      	break;
		      case "series":
		      	newInproceedings.setSeries(entry.getValue());
		      	break;
		      case "pages":
		      	newInproceedings.setPages(entry.getValue());
		      	break;
		      case "address":
		      	newInproceedings.setAddress(entry.getValue());
		      	break;
		      case "month":
		      	newInproceedings.setMonth(entry.getValue());
		      	break;
		      case "organization":
		      	newInproceedings.setOrganization(entry.getValue());
		      	break;
		      case "publisher":
		      	newInproceedings.setPublisher(entry.getValue());
		      	break;
		      case "note":
		      	newInproceedings.setNote(entry.getValue());
		      	break;
		      case "key":
		      	newInproceedings.setKey(entry.getValue());
		      	break;
		      default:
		      	throw new ParsingError("[@inproceedings] " + entry.getKey() + " não é um campo válido.");
		      	break;
		    }
		  }
		}
		entradas.get("inproceedings").add(newInproceedings);
		if (checkingTwoParams == 0) throw new ParsingError("[@inproceedings] Volume e Number não podem coexistir");
	  } catch (ParsingError e) {
	    System.out.println(e.getMessage());
	  }
	}
}

void manual(HashMap<String, String > dados) : {}
{
  {
	  try {
	    String reference = dados.get("reference"), title = dados.get("title");

		if(reference == null || title == null) throw new ParsingError("[@manual] : Estes campos são obrigatórios: reference, title.");
		else {
		  Manual novoManual = new Manual(reference, title);
		  for (HashMap.Entry<String, String > entry : dados.entrySet()) {
		    if (entry.getKey() == "reference" || entry.getKey() == "title"){}
		    else{
		    switch(entry.getKey())
		    {
		      case "author":
		      	novoManual.setAuthor(entry.getValue());
		      	break;
		      case "organization":
		      	novoManual.setOrganization(entry.getValue());
		      	break;
		      case "address":
		      	novoManual.setAddress(entry.getValue());
		      	break;
		      case "edition":
		      	novoManual.setEdition(entry.getValue());
		      	break;
		      case "month":
		      	novoManual.setMonth(entry.getValue());
		      	break;
		      case "year":
		      	novoManual.setYear(entry.getValue());
		      	break;
		      case "note":
		      	novoManual.setNote(entry.getValue());
		      	break;
		      case "key":
		      	novoManual.setKey(entry.getValue());
		      	break;
		      default:
		      	throw new ParsingError("[@manual] " + entry.getKey() + " não é um campo válido.");
		      	break;
		    }
		  }
		  }
		  entradas.get("manual").add(novoManual);
		}
	  } catch (ParsingError e)
	  {
	    System.out.println(e.getMessage());
	  }
  	}
}

void mastersthesis(HashMap<String, String > dados) : {}
{
	{
	  try {
	    String reference = dados.get("reference"), title = dados.get("title"), author = dados.get("author"), school = dados.get("school"), year = dados.get("year");

		if(reference == null || title == null || author == null || school == null || year == null) throw new ParsingError("[@mastersthesis] : Estes campos são obrigatórios: reference, title, author, title, school, year.");
		else {
		  Mastersthesis novoMasterThesis = new Mastersthesis(reference, author, title, school, year);
		  for (HashMap.Entry<String, String > entry : dados.entrySet()) {
		    if (entry.getKey() == "reference" || entry.getKey() == "title" || entry.getKey() == "author" || entry.getKey() == "school" || entry.getKey() == "year"){}
		    else{
		    switch(entry.getKey())
		    {
		      case "type":
		      	novoMasterThesis.setType(entry.getValue());
		      	break;
		      case "address":
		      	novoMasterThesis.setAddress(entry.getValue());
		      	break;
		      case "month":
		      	novoMasterThesis.setMonth(entry.getValue());
		      	break;
		      case "note":
		      	novoMasterThesis.setNote(entry.getValue());
		      	break;
		      case "key":
		      	novoMasterThesis.setKey(entry.getValue());
		      	break;
		      default:
		      	throw new ParsingError("[@mastersthesis] " + entry.getKey() + " não é um campo válido.");
		      	break;
		    }
		  }
		  }
		  entradas.get("mastersthesis").add(novoMasterThesis);
		}
	  } catch (ParsingError e)
	  {
	    System.out.println(e.getMessage());
	  }
  	}
 }
  	*/