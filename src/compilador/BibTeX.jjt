PARSER_BEGIN(BibTeX)

package compilador;
import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.io.IOException;
import java.io.FileInputStream;
import java.util.Scanner;
import elementos.*;

public class BibTeX {

	private static HashMap < String, HashMap < String, String > > symbolTable = new HashMap < String, HashMap < String, String >> ();
	private static HashMap < String, Entry > entradas = new HashMap < String, Entry > ();
	private static ArrayList <Entry > entryList = new ArrayList <Entry>();

	private static Entry entradaRecente = null;
	private static SimpleNode simpleN;
	private static String entryReading = null;
	private static int lastGoodLine = 0;

	public static void main(String args[]) throws ParseException, IOException {

		String fname = "";
		Scanner sc = new Scanner(System. in );
		while (fileExist(fname) != true) {
			System.out.print("Introduza o ficheiro que pretende usar > ");
			fname = sc.nextLine();
			System.out.print("\n\n\n\n");
		}

		BibTeX parser = new BibTeX(new FileInputStream(new File(fname)));
		simpleN = parser.start();

		//simpleN.dump("");
		semanticAnalysis();
	

		for (HashMap.Entry < String, Entry> entry: entradas.entrySet()) {
			String onKey = entry.getKey();
			entradas.get(onKey).createFile();
		}
		
		sc.close();
	}

	private static boolean fileExist(String filename) {
		File file = new File(filename);
		return file.exists();
	}
}



PARSER_END(BibTeX)

SKIP: {
	" " | "\r" | "\t" | "\n"
}

TOKEN: // 1st level (entries)
{ < ARTICLE: "@article" > | < BOOK: "@book" > | < BOOKLET: "@booklet" > | < CONFERENCE: "@conference" > | < INBOOK: "@inbook" > | < INCOLLECTION: "@incollection" > | < INPROCEEDINGS: "@inproceedings" > | < MANUAL: "@manual" > | < MASTERSTHESIS: "@mastersthesis" > | < MISC: "@misc" > | < PHDTHESIS: "@phdthesis" > | < PROCEEDINGS: "@proceedings" > | < TECHREPORT: "@techreport" > | < UNPUBLISHED: "@unpublished" >
}

TOKEN: // 2nd level [fields]
{ < AUTHOR: "author" > | < CROSSREF: "crossref" > | < TITLE: "title" > | < JOURNAL: "journal" > | < YEAR: "year" > | < VOLUME: "volume" > | < NUMBER: "number" > | < PAGES: "pages" > | < MONTH: "month" > | < NOTE: "note" > | < KEY: "key" > | < EDITOR: "editor" > | < PUBLISHER: "publisher" > | < SERIES: "series" > | < ADDRESS: "address" > | < EDITION: "edition" > | < HOWPUBLISHED: "howpublished" > | < CHAPTER: "chapter" > | < BOOKTITLE: "booktitle" > | < ORGANIZATION: "organization" > | < SCHOOL: "school" > | < INSTITUTION: "institution" >
}

TOKEN: { < FIELD: "\"" ( < WORD > | " ") * "\"" > | < WORD: ( < CHARACTER > | < INTEGER > ) + > | < CHARACTER: ["A" - "Z", "a" - "z"] > | < INTEGER: ["0" - "9"] > | < OPENBRACES: "{" > | < CLOSEBRACES: "}" > | < COMMA: "," > | < PERIOD: "." > | < EQUALS: "=" > | < DASH: "-" >
}

void imprimirSymbolTable(): {} {
	{
		System.out.println("### TABELA DE SIMBOLOS ###");
		for (HashMap.Entry < String, HashMap < String, String >> entry: symbolTable.entrySet()) {
			String onKey = entry.getKey();
			for (HashMap.Entry < String, String > entrada: entry.getValue().entrySet()) {
				System.out.println("Key = " + onKey + "|| " + "Entry = " + entrada.getKey() + ", Value = " + entry.getValue().get(entrada.getKey()));
			}
		}
	}
}

SimpleNode start(): {
	Token t1;
} {
	(
	(
	t1 = < ARTICLE > | t1 = < BOOK > | t1 = < BOOKLET > | t1 = < CONFERENCE > | t1 = < INBOOK > | t1 = < INCOLLECTION > | t1 = < INPROCEEDINGS > | t1 = < MANUAL > | t1 = < MASTERSTHESIS > | t1 = < MISC > | t1 = < PHDTHESIS > | t1 = < PROCEEDINGS > | t1 = < TECHREPORT > | t1 = < UNPUBLISHED > ) {
		entryReading = t1.image;
		switch (entryReading) {
			case "@article":
				entradaRecente = new Article();
				break;
			case "@book":
				entradaRecente = new Book();
				break;
			case "@booklet":
				entradaRecente = new Booklet();
				break;
			case "@conference":
				entradaRecente = new Conference();
				break;
			case "@inbook":
				entradaRecente = new Inbook();
				break;
			case "@incollection":
				entradaRecente = new Incollection();
				break;
			case "@inproceedings":
				entradaRecente = new Inproceedings();
				break;
			case "@manual":
				entradaRecente = new Manual();
				break;
			case "@mastersthesis":
				entradaRecente = new Mastersthesis();
				break;
			case "@misc":
				entradaRecente = new Misc();
				break;
			case "@phdthesis":
				entradaRecente = new Phdthesis();
				break;
			case "@proceedings":
				entradaRecente = new Proceedings();
				break;
			case "@techreport":
				entradaRecente = new Techreport();
				break;
			case "@unpublished":
				entradaRecente = new Unpublished();
				break;
		}
	} < OPENBRACES > data() < CLOSEBRACES > ) + < EOF > {
		return jjtThis;
	}
}

void data(): {
	Token t1 = null;
} {
	(t1 = < WORD > ) {
		entradas.put(t1.image, entradaRecente);
		symbolTable.put(t1.image, new HashMap < String, String > ());
		entryReading = t1.image;
		lastGoodLine = t1.endLine;
		jjtThis.jjtSetValue(t1);
		//System.out.println(jjtThis.jjtGetValue());
	} < COMMA > // TODO: Alterar
	(t1 = atribute() < COMMA > ) *
}

Token atribute(): {
	Token t1 = null;
} {
	(t1 = < AUTHOR > | t1 = < CROSSREF > | t1 = < TITLE > | t1 = < JOURNAL > | t1 = < YEAR > | t1 = < VOLUME > | t1 = < NUMBER > | t1 = < PAGES > | t1 = < MONTH > | t1 = < NOTE > | t1 = < KEY > | t1 = < EDITOR > | t1 = < PUBLISHER > | t1 = < SERIES > | t1 = < ADDRESS > | t1 = < EDITION > | t1 = < HOWPUBLISHED > | t1 = < CHAPTER > | t1 = < BOOKTITLE > | t1 = < ORGANIZATION > | t1 = < SCHOOL > | t1 = < INSTITUTION > )
	definition(t1) {
		jjtThis.jjtSetValue(t1);
		//System.out.println(" " + jjtThis.jjtGetValue());
		return t1;
	}
}

Token definition(Token attr): {
	Token field = null;
} { < EQUALS > (field = < FIELD > ) ? {
		{
			try {
				if (field == null) throw new ParsingError("[WARNING-Linha " + lastGoodLine + "] Variavel sem valor declarado.");
				else {
					jjtThis.jjtSetValue(field.image);
					if (symbolTable.get(entryReading).get(attr.image) == null) {
						lastGoodLine = field.endLine;
						symbolTable.get(entryReading).put(attr.image, field.image);
					} else throw new ParsingError("[WARNING-Linha " + field.beginLine + "] A referência " + entryReading + " tem o campo \'" + attr.image + "\' repetido.");
				}
			} catch (ParsingError e) {
				System.out.println(e.getMessage());
			}
		}
		return field;
	}
}

void semanticAnalysis(): {} {
	{
		for (int i = 0; i < simpleN.jjtGetNumChildren(); i++) {
			SimpleNode temp = (SimpleNode) simpleN.jjtGetChild(i);
			Token tempToken = (Token) temp.jjtGetValue();
			String reference = tempToken.image;
			for (int j = 0; j < temp.jjtGetNumChildren(); j++) {
				SimpleNode temp_ = (SimpleNode) temp.jjtGetChild(j);
				Token tempToken_ = (Token) temp_.jjtGetValue();

				if (tempToken_.image.equals("crossref")) {
					String nameWithoutQuotes = symbolTable.get(reference).get("crossref").substring(1, symbolTable.get(reference).get("crossref").length() - 1);
					Entry temporaria = entradas.get(nameWithoutQuotes);
					if (temporaria == null) {
						System.out.println("[WARNING-Linha " + tempToken_.beginLine + "] A referência " + reference + " está a referenciar um objeto que não existe.");
						symbolTable.get(reference).remove("crossref");
					} else {
						addingToObjects(tempToken, reference, tempToken_.image, symbolTable.get(reference).get(tempToken_.image));
					}
				} else {
					addingToObjects(tempToken,reference, tempToken_.image, symbolTable.get(reference).get(tempToken_.image));
					}
			}
			try {
				String erros = entradas.get(reference).isValid();
				if (erros != "") throw new ParsingError("[ERROR-Linha " + tempToken.beginLine + "] A referência " + reference + " precisa do(s) seguinte(s) campo(s) \'" + erros + "\'.");
			} catch (ParsingError e) {
				System.out.println(e.getMessage());
				System.exit(0);
			}
		}
		SimpleNode temp = (SimpleNode) simpleN.jjtGetChild(0);
	}
}

void addingToObjects(Token temp, String reference, String attribute, String value): {} {
	{		  
		  if(attribute.equals("crossref")) {
			if (reference.equals(value.substring(1,value.length()-1))){
				System.out.println("[ERROR-Linha " + temp.beginLine + "] CrossRef a referenciar o mesmo objecto");
				System.exit(0);
	  	  	}
		  } else if (attribute.equals("month"))
		  {
		  } else if (attribute.equals("year"))
		  {
		  }else if (attribute.equals("volume"))
		  {
		  }else if (attribute.equals("number"))
		  {
		  }else if (attribute.equals("pages"))
		  {
		    
			String finale = value.substring(1,value.length()-1);
			if(finale.matches("[0-9]+")){
			}
			else if(finale.matches("[0-9-]+")){
				
				String[] pagesSplit = finale.split("-");
				if(pagesSplit.length == 1){
					System.out.println("Tem um '-' a mais mas foi convertido.");
				}
				
				else if(pagesSplit.length == 2){
					int part1 = Integer.parseInt(pagesSplit[0]);
					int part2 = Integer.parseInt(pagesSplit[1]);
					
					if(part1 > part2){
						String novaPages = pagesSplit[1] + "-" + pagesSplit[0];
						value = "\"" + novaPages + "\"";
					}
					
					else if(part1 == part2){
						value = "\"" + pagesSplit[0] + "\"";
					}
				}
				
				else{
					/*try {
						throw new ParseException("Pages not in the correct format.");
					} catch (ParseException e) {
						e.printStackTrace();
					}*/
					System.out.println("Pages not in the correct format.");
				}
				
			}
			
			else{
				/*try {
					throw new ParseException("Pages not in the correct format.");
				} catch (ParseException e) {
					e.printStackTrace();
				}*/
				System.out.println("Pages not in the correct format.");
			
		}
		    
		  }else if (attribute.equals("chapter"))
		  {
		  }
		  
		String attr = attribute.toLowerCase();
		if (!entradas.get(reference).addattribute(attr, value)){
			System.out.println("[WARNING-Linha " + temp.beginLine + "] A referência \"" + reference + "\" tem o campo \'" + attribute + "\' que não é um atributo de " + entradas.get(reference).getClass().getSimpleName());
		}
	}
}