PARSER_BEGIN(BibTeX)

package compilador;
import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.io.IOException;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.util.Scanner;
import elementos.*;

public class BibTeX {
	/* https://java.net/projects/javacc/lists/users/archive/2006-02/message/15
		We're using hashmap instead of hashtable because we are not dealing with concurrency on threads. 
	*/
  private static HashMap<String, HashMap<String, String> > symbolTable = new HashMap<String, HashMap<String, String>>();
  private static HashMap<String, ArrayList< Entry > > entradas = new HashMap<String, ArrayList< Entry > >();
  private static SimpleNode arvore;
  private static String entryReading = null;
  public static void main(String args []) throws ParseException, IOException {
    
	symbolTable.put("@article", new HashMap<String, String >());
    symbolTable.put("@book", new HashMap<String, String >());
    symbolTable.put("@booklet", new HashMap<String, String >());
    symbolTable.put("@conference", new HashMap<String, String >());
    symbolTable.put("@inbook", new HashMap<String, String >());
    symbolTable.put("@incollection", new HashMap<String, String >());
    symbolTable.put("@inproceedings", new HashMap<String, String >());
    symbolTable.put("@manual", new HashMap<String, String >());
    symbolTable.put("@mastersthesis", new HashMap<String, String >());
    symbolTable.put("@misc", new HashMap<String, String >());
    symbolTable.put("@phdthesis", new HashMap<String, String >());
    symbolTable.put("@proceedings", new HashMap<String, String >());
    symbolTable.put("@techreport", new HashMap<String, String >());
    symbolTable.put("@unpublished", new HashMap<String, String >());

    entradas.put("article", new ArrayList<Entry >());
    entradas.put("book", new ArrayList<Entry >());
    entradas.put("booklet", new ArrayList<Entry >());
    entradas.put("conference", new ArrayList<Entry >());
    entradas.put("inbook", new ArrayList<Entry >());
    entradas.put("incollection", new ArrayList<Entry >());
    entradas.put("inproceedings", new ArrayList<Entry >());
    entradas.put("manual", new ArrayList<Entry >());
    entradas.put("mastersthesis", new ArrayList<Entry >());
    entradas.put("misc", new ArrayList<Entry >());
    entradas.put("phdthesis", new ArrayList<Entry >());
    entradas.put("proceedings", new ArrayList<Entry >());
    entradas.put("techreport", new ArrayList<Entry >());
    entradas.put("unpublished", new ArrayList<Entry >());


    String fname = "";
    Scanner sc = new Scanner(System.in);
    while (fileExist(fname) != true) {
	    System.out.print("Introduza o ficheiro que pretende usar > ");
	    fname = sc.nextLine();
	}

	BibTeX parser = new BibTeX(new FileInputStream(new File(fname)));
	arvore = parser.start();
	//arvore.dump("");
	//imprimirSymbolTable();
	semanticAnalysis();
	sc.close();
  }

  private static boolean fileExist(String filename) {
	File file = new File(filename);
	return file.exists();
  }
}

PARSER_END(BibTeX)

SKIP :
{
	" " | "\r" | "\t" | "\n"
}

TOKEN : // 1st level (entries)
{
	< ARTICLE : "@article" > |
	< BOOK : "@book" > |
	< BOOKLET : "@booklet" > |
	< CONFERENCE : "@conference" > |
	< INBOOK : "@inbook" > |
	< INCOLLECTION : "@incollection" > |
	< INPROCEEDINGS : "@inproceedings" > |
	< MANUAL : "@manual" > |
	< MASTERSTHESIS : "@mastersthesis" > |
	< MISC : "@misc" > |
	< PHDTHESIS : "@phdthesis" > |
	< PROCEEDINGS : "@proceedings" > |
	< TECHREPORT : "@techreport" > |
	< UNPUBLISHED : "@unpublished" >
}

TOKEN : // 2nd level [fields]
{
	< AUTHOR : "author" > |
	< TITLE : "title" > |
	< JOURNAL : "journal" > |
	< YEAR : "year" > |
	< VOLUME : "volume" > |
	< NUMBER : "number" > |
	< PAGES : "pages" > |
	< MONTH : "month" > |
	< NOTE : "note" > |
	< KEY : "key" > |
	< EDITOR : "editor" > |
	< PUBLISHER : "publisher" > |
	< SERIES : "series" > |
	< ADDRESS : "address" > |
	< EDITION : "edition" > |
	< HOWPUBLISHED : "howpublished" > |
	< CHAPTER : "chapter" > |
	< TYPE : "type" > |
	< BOOKTITLE : "booktitle" > |
	< ORGANIZATION : "organization" > |
	< SCHOOL : "school" > |
	< INSTITUTION : "institution" >
}

TOKEN :
{
	< FIELD : "\"" (< WORD > | " ")+ "\"" > |
	< WORD : (< CHARACTER > | < INTEGER >)+ > |
	< CHARACTER : ["A"-"Z", "a"-"z"] > |
	< INTEGER : ["0"-"9"] > |
	< OPENBRACES : "{" > |
	< CLOSEBRACES : "}" > |
	< COMMA : "," > |
	< EQUALS : "=" >
}

void imprimirSymbolTable() :{}
{
  {
	for (HashMap.Entry<String, HashMap<String, String >> entry : symbolTable.entrySet()) {
        	String onKey = entry.getKey();
        	for( HashMap.Entry<String, String> entrada : entry.getValue().entrySet()){
            System.out.println("Key = " + onKey + "|| " + "Entry = " + entrada.getKey() + ", Value = " + entry.getValue().get(entrada.getKey()));
      }
    }
  }
}

SimpleNode start() : {Token t1;}
{
  (
    (
	t1 = < ARTICLE > |
	t1 = < BOOK > |
	t1 = < BOOKLET > |
	t1 = < CONFERENCE > |
	t1 = < INBOOK > |
	t1 = < INCOLLECTION >  |
	t1 = < INPROCEEDINGS > |
	t1 = < MANUAL > |
	t1 = < MASTERSTHESIS > |
	t1 = < MISC > |
	t1 = < PHDTHESIS > |
	t1 = < PROCEEDINGS > |
	t1 = < TECHREPORT >  |
	t1 = < UNPUBLISHED >
	)
	{entryReading = t1.image;}
	< OPENBRACES >
	data()
	< CLOSEBRACES >
)+ < EOF >
	{
	jjtThis.jjtSetValue(t1.image);
	//System.out.println(jjtThis.jjtGetValue());
    return jjtThis;
  }
}

Token atribute(): {Token t1 = null;}
{
  (
  	t1 = < AUTHOR> |
	t1 = < TITLE> |
	t1 = < JOURNAL> |
	t1 = < YEAR> |
	t1 = < VOLUME> |
	t1 = < NUMBER> |
	t1 = < PAGES> |
	t1 = < MONTH> |
	t1 = < NOTE> |
	t1 = < KEY> |
	t1 = < EDITOR> |
	t1 = < PUBLISHER> |
	t1 = < SERIES> |
	t1 = < ADDRESS> |
	t1 = < EDITION> |
	t1 = < HOWPUBLISHED> |
	t1 = < CHAPTER> |
	t1 = < TYPE> |
	t1 = < BOOKTITLE> |
	t1 = < ORGANIZATION> |
	t1 = < SCHOOL> |
	t1 = < INSTITUTION>
)
	definition(t1)
	{
	  return t1;
	}
}

void data(): {Token t1 = null;}
{
  (t1 = < WORD >) {symbolTable.get(entryReading).put("reference", t1.image);} <COMMA > // TODO: Alterar
  (t1 = atribute()
  {
    jjtThis.jjtSetValue(t1.image);
    //System.out.println(jjtThis.jjtGetValue());
  }< COMMA >)*
}

Token definition(Token attr) : {Token field = null;}
{
    < EQUALS > field = < FIELD >
  {
    if (field == null) System.out.println("There was an error in syntactic analysis");
    else
    {
      jjtThis.jjtSetValue(field.image);
      //System.out.println(entryReading);
      symbolTable.get(entryReading).put(attr.image, field.image);
    }
    return field;
  }
}


void semanticAnalysis() :{}
{
	{
	for (HashMap.Entry<String, HashMap<String, String >> entry : symbolTable.entrySet()) {
        	String onKey = entry.getKey();
        	switch(onKey)
        	{
        	  case "@article":
        	  	article(entry.getValue());
        	  	break;
        	  case "@book":
        	  	//book(entry.getValue());
        	  	break;
        	  case "@booklet":
        	  	//booklet(entry.getValue());
        	  	break;
        	  case "@conference":
        	  	//conference(entry.getValue());
        	  	break;
        	  case "@inbook":
        	  	//inbook(entry.getValue());
        	  	break;
        	  case "@incollection":
        	  	//incollection(entry.getValue());
        	  	break;
        	  case "@inproceedings":
        	  	//inproceedings(entry.getValue());
        	  	break;
        	  case "@manual":
        	  	manual(entry.getValue());
        	  	break;
        	  case "@mastersthesis":
        	  	mastersthesis(entry.getValue());
        	  	break;
        	  case "@misc":
        	  	//misc(entry.getValue());
        	  	break;
        	  case "@phdthesis":
        	  	//phdthesis(entry.getValue());
        	  	break;
        	  case "@proceedings":
        	  	//proceedings(entry.getValue());
        	  	break;
        	  case "@techreport":
        	  	//techreport(entry.getValue());
        	  	break;
        	  case "@unpublished":
        	  	//unpublished(entry.getValue());
        	  	break;
        	}
      }
    }
}

void article(HashMap<String, String > dados) : {}
{
	{
	  try {
	    String reference = dados.get("reference"), author = dados.get("author"), title = dados.get("title"), journal = dados.get("journal"), year = dados.get("year");

		if(reference == null || author == null || title == null || journal == null || year == null) throw new ParsingError("[@Article] : Estes campos são obrigatórios: author, title, journal, year.");
		else {
		  Article novoArtigo = new Article(reference, author, title, journal, year);
		  for (HashMap.Entry<String, String > entry : dados.entrySet()) {
		    if (entry.getKey() == "reference" || entry.getKey() == "author" || entry.getKey() == "title" || entry.getKey() == "journal" || entry.getKey() == "year"){}
		    else{
		    switch(entry.getKey())
		    {
		      case "volume":
		      	novoArtigo.setVolume(entry.getValue());
		      	break;
		      case "number":
		      	novoArtigo.setNumber(entry.getValue());
		      	break;
		      case "pages":
		      	novoArtigo.setPages(entry.getValue());
		      	break;
		      case "month":
		      	novoArtigo.setMonth(entry.getValue());
		      	break;
		      case "note":
		      	novoArtigo.setNote(entry.getValue());
		      	break;
		      case "key":
		      	novoArtigo.setKey(entry.getValue());
		      	break;
		      default:
		      	throw new ParsingError("[@Article] " + entry.getKey() + " não é um campo válido.");
		      	break;
		    }
		  }
		  }
		  entradas.get("article").add(novoArtigo);
		}
	  } catch (ParsingError e)
	  {
	    System.out.println(e.getMessage());
	  }
  	}
}

void book(HashMap<String, String > dados) : {}
{
	
    {
      try {
         String reference = dados.get("reference"), author = dados.get("author"), editor = dados.get("editor"), title = dados.get("title"), publisher = dados.get("publisher"), year = dados.get("year");
		if(reference == null || !(author == null ^ editor == null) || title == null || publisher == null || year == null) throw new ParsingError("[@book] : Estes campos são obrigatórios: author/editor, title, publisher, year.");
		else {
		  if (author != null)
		  {
		    Book newBook = new Book(reference, "author", author, title, journal, year);
		  }
		  else
		  {
		    Book newBook = new Book(reference, "editor", editor, title, journal, year);
		  }
		
		      if(!(dados.get("volume")== null && dados.get("number")== null))
		      {throw new ParsingError("[@book] " + entry.getKey() + " não é um campo compatível.");}
		      else
		  {
		    
		  
		  for (HashMap.Entry<String, String > entry : dados.entrySet()) {
		    if (entry.getKey() == "reference" || entry.getKey() == "author" || entry.getKey() == "editor" || entry.getKey() == "title" || entry.getKey() == "publisher" || entry.getKey() == "year"){}
		    else{
		        
		    switch(entry.getKey())
		    {
		      case "volume":
		      	newBook.setVolume(entry.getValue());
		      	break;
		      case "number":
		      	newBook.setNumber(entry.getValue());
		      	break;
		      case "series":
		      	newBook.setSeries(entry.getValue());
		      	break;
		      case "address":
		      	newBook.setAddress(entry.getValue());
		      	break;
		      case "edition":
		      	newBook.setEdition(entry.getValue());
		      	break;
		      case "month":
		      	newBook.setMonth(entry.getValue());
		      	break;
		      	case "note":
		      	newBook.setNote(entry.getValue());
		      	break;
		      	case "key":
		      	newBook.setKey(entry.getValue());
		      	break;
		      default:
		      	throw new ParsingError("[@book] " + entry.getKey() + " não é um campo válido.");
		      	break;
		    }
		  
		  
		   }
		  }
		  entradas.get("book").add(newBook);
       }
      }

	  } catch (ParsingError e) {
	    System.out.println(e.getMessage());
	  }
  	}
}

void booklet() :{}
{
  {
	  try {
	    String reference = dados.get("reference"), title = dados.get("title");

		if(reference == null || author == null) throw new ParsingError("[@booklet] : Este campo é obrigatóris:  title.");
		else {
		  Booklet newBooklet = new Booklet(reference, title);
		  for (HashMap.Entry<String, String > entry : dados.entrySet()) {
		    if (entry.getKey() == "reference" || entry.getKey() == "title"){}
		    else{
		    switch(entry.getKey())
		    {
		      case "author":
		      	newBooklet.setVolume(entry.getValue());
		      	break;
		      case "howpublished":
		      	newBooklet.setNumber(entry.getValue());
		      	break;
		      case "address":
		      	newBooklet.setPages(entry.getValue());
		      	break;
		      case "month":
		      	newBooklet.setMonth(entry.getValue());
		      	break;
		      case "year":
		      	newBooklet.setYear(entry.getValue());
		      	break;
		      case "note":
		      	newBooklet.setNote(entry.getValue());
		      	break;
		      case "key":
		      	newBooklet.setKey(entry.getValue());
		      	break;
		      default:
		      	throw new ParsingError("[@booklet] " + entry.getKey() + " não é um campo válido.");
		      	break;
		    }
		  }
		  }
		  entradas.get("booklet").add(newBooklet);
		}
	  } catch (ParsingError e)
	  {
	    System.out.println(e.getMessage());
	  }
  	}
}

void conference() : {Token reference = null, author = null, title = null, booktitle = null, year = null, editor = null, volume = null, number = null, series = null, pages = null, address = null, month = null, organization = null, publisher = null, note = null, key = null;}
{
	< OPENBRACES > (reference = <WORD>)? < COMMA >
	(< AUTHOR > author = definition() < COMMA >)?
	(< TITLE > title = definition() < COMMA >)?
	(< BOOKTITLE > booktitle = definition() < COMMA >)?
	(< YEAR > year = definition() < COMMA >)?
    (< EDITOR > editor = definition() < COMMA >)?
    ( ((<VOLUME> volume = definition()) | (< NUMBER > number = definition())) < COMMA >)?
    (< SERIES > series = definition() < COMMA >)?
    (< PAGES > pages = definition() < COMMA >)?
    (< ADDRESS > address = definition() < COMMA >)?
    (< MONTH > month = definition() < COMMA >)?
    (< ORGANIZATION > organization = definition() < COMMA >)?
    (< PUBLISHER > publisher = definition() < COMMA >)?
    (< NOTE > note = definition() < COMMA >)?
    (< KEY > key = definition() < COMMA >)?
    < CLOSEBRACES >
	{
	 try {
	  if (reference == null) throw new ParsingError("[@conference] : Falta uma chave de citação!");
		if (author != null && title != null && booktitle != null && year != null)
		{
		  Conference conference = new Conference(reference.image, author.image, title.image, booktitle.image, year.image);
		  if (editor != null) conference.setEditor(editor.image);
		  if (volume != null) conference.setVolume(volume.image);
		  if (number != null) conference.setNumber(number.image);
		  if (series != null) conference.setSeries(series.image);
		  if (pages != null) conference.setPages(pages.image);
		  if (address != null) conference.setAddress(address.image);
		  if (month != null) conference.setMonth(month.image);
		  if (organization != null) conference.setOrganization(organization.image);
		  if (publisher != null) conference.setPublisher(publisher.image);
		  if (note != null) conference.setNote(note.image);
		  if (key != null) conference.setKey(key.image);
		} else {
		  throw new ParsingError("[@conference] : Estes campos são obrigatórios: author, title, journal, year, volume.");
		}
	  } catch (ParsingError e) {
	    System.out.println(e.getMessage());
	  }
  	}
}

void misc(HashMap<String, String > dados) : {}
{
	{
	  try {
	   	String reference = dados.get("reference");

		Misc novoMisc = new Misc(reference);

		 for (HashMap.Entry<String, String > entry : dados.entrySet()) {
		    switch(entry.getKey())
		    {
		      case "author":
		      	novoMisc.setAuthor(entry.getValue());
		      	break;
		      case "title":
		      	novoMisc.setTitle(entry.getValue());
		      	break;
		      case "howpublished":
		      	novoMisc.setHowpublished(entry.getValue());
		      	break;
		      case "month":
		      	novoMisc.setMonth(entry.getValue());
		      	break;
		      case "year":
		      	novoMisc.setYear(entry.getValue());
		      	break;
		      case "note":
		      	novoMisc.setNote(entry.getValue());
		      	break;
		      case "key":
		      	novoMisc.setKey(entry.getValue());
		      	break;
		      default:
		      	throw new ParsingError("[@Misc] " + entry.getKey() + " não é um campo válido.");
		      	break;
		    }
		  
		  }
		  entradas.get("misc").add(novoMisc);
		}
	  } catch (ParsingError e)
	  {
	    System.out.println(e.getMessage());
	  }
 
}

void phdthesis(HashMap<String, String > dados) : {}
{
	{
	  try {
	    String reference = dados.get("reference"), author = dados.get("author"), title = dados.get("title"), school = dados.get("school"), year = dados.get("year");

		if(reference == null || author == null || title == null || school == null || year == null) throw new ParsingError("[@Phdthesis] : Estes campos são obrigatórios: author, title, school, year.");
		else {
		  Phdthesis novoPhd = new Phdthesis(reference, author, title, school, year);
		  for (HashMap.Entry<String, String > entry : dados.entrySet()) {
		    if (entry.getKey() == "reference" || entry.getKey() == "author" || entry.getKey() == "title" || entry.getKey() == "school" || entry.getKey() == "year"){}
		    else{
		    switch(entry.getKey())
		    {
		      case "type":
		      	novoPhd.setType(entry.getValue());
		      	break;
		      case "address":
		      	novoPhd.setAddress(entry.getValue());
		      	break;
		      case "month":
		      	novoPhd.setMonth(entry.getValue());
		      	break;
		      case "note":
		      	novoPhd.setNote(entry.getValue());
		      	break;
		      case "key":
		      	novoPhd.setKey(entry.getValue());
		      	break;
		      default:
		      	throw new ParsingError("[@Phdthesis] " + entry.getKey() + " não é um campo válido.");
		      	break;
		    }
		  }
		  }
		  entradas.get("phdthesis").add(novoPhd);
		}
	  } catch (ParsingError e)
	  {
	    System.out.println(e.getMessage());
	  }
  	}
}

void proceedings(HashMap<String, String > dados) : {}
{
	{
	  try {
	    String reference = dados.get("reference"), title = dados.get("title"), year = dados.get("year");

		if(reference == null || title == null || year == null) throw new ParsingError("[@Proceedings] : Estes campos são obrigatórios: title, year.");
		else {
		  Proceedings novoProceeding = new Proceedings(reference, title, year);
		  for (HashMap.Entry<String, String > entry : dados.entrySet()) {
		    if (entry.getKey() == "reference" || entry.getKey() == "title" || entry.getKey() == "year"){}
		    else{
		    switch(entry.getKey())
		    {
		      case "editor":
		      	novoProceeding.setEditor(entry.getValue());
		      	break;
		      case "volume":
		      	novoProceeding.setVolume(entry.getValue());
		      	break;
		      case "number":
		      	novoProceeding.setNumber(entry.getValue());
		      	break;
		      case "series":
		      	novoProceeding.setSeries(entry.getValue());
		      	break;
		      case "address":
		      	novoProceeding.setAddress(entry.getValue());
		      	break;
		      case "month":
		      	novoProceeding.setMonth(entry.getValue());
		      	break;
		      case "publisher":
		      	novoProceeding.setPublisher(entry.getValue());
		      	break;
		      case "organization":
		      	novoProceeding.setOrganization(entry.getValue());
		      	break;
		      case "note":
		      	novoProceeding.setNote(entry.getValue());
		      	break;
		      case "key":
		      	novoProceeding.setKey(entry.getValue());
		      	break;
		      default:
		      	throw new ParsingError("[@Proceedings] " + entry.getKey() + " não é um campo válido.");
		      	break;
		    }
		  }
		  }
		  entradas.get("proceedings").add(novoProceeding);
		}	
	  } catch (ParsingError e)
	  {
	    System.out.println(e.getMessage());
	  }
  	}
}

void techreport(HashMap<String, String > dados) : {}
{
	{
	  try {
	    String reference = dados.get("reference"), author = dados.get("author"), title = dados.get("title"), institution = dados.get("institution"), year = dados.get("year");

		if(reference == null || author == null || title == null || institution == null || year == null) throw new ParsingError("[@Techreport] : Estes campos são obrigatórios: author, title, institution, year.");
		else {
		  Techreport novoTechreport = new Techreport(reference, author, title, institution, year);
		  for (HashMap.Entry<String, String > entry : dados.entrySet()) {
		    if (entry.getKey() == "reference" || entry.getKey() == "author" || entry.getKey() == "title" || entry.getKey() == "institution" || entry.getKey() == "year"){}
		    else{
		    switch(entry.getKey())
		    {
		      case "type":
		      	novoTechreport.setType(entry.getValue());
		      	break;
		      case "number":
		      	novoTechreport.setNumber(entry.getValue());
		      	break;
		      case "address":
		      	novoTechreport.setAddress(entry.getValue());
		      	break;
		      case "month":
		      	novoTechreport.setMonth(entry.getValue());
		      	break;
		      case "note":
		      	novoTechreport.setNote(entry.getValue());
		      	break;
		      case "key":
		      	novoTechreport.setKey(entry.getValue());
		      	break;
		      default:
		      	throw new ParsingError("[@Techreport] " + entry.getKey() + " não é um campo válido.");
		      	break;
		    }
		  }
		  }
		  entradas.get("techreport").add(novoTechreport);
		}	
	  } catch (ParsingError e)
	  {
	    System.out.println(e.getMessage());
	  }
  	}
}

void unpublished(HashMap<String, String > dados) : {}
{
	{
	  try {
	    String reference = dados.get("reference"), author = dados.get("author"), title = dados.get("title"), note = dados.get("note");

		if(reference == null || author == null || title == null || note == null) throw new ParsingError("[@Unpublished] : Estes campos são obrigatórios: author, title, note.");
		else {
		  Unpublished novoUnpublished = new Unpublished(reference, author, title, note);
		  for (HashMap.Entry<String, String > entry : dados.entrySet()) {
		    if (entry.getKey() == "reference" || entry.getKey() == "author" || entry.getKey() == "title" || entry.getKey() == "note"){}
		    else{
		    switch(entry.getKey())
		    {
		      case "month":
		      	novoUnpublished.setMonth(entry.getValue());
		      	break;
		      case "year":
		      	novoUnpublished.setYear(entry.getValue());
		      	break;
		      case "key":
		      	novoUnpublished.setKey(entry.getValue());
		      	break;
		      default:
		      	throw new ParsingError("[@Unpublished] " + entry.getKey() + " não é um campo válido.");
		      	break;
		    }
		  }
		  }
		  entradas.get("unpublished").add(novoUnpublished);
		}	
	  } catch (ParsingError e)
	  {
	    System.out.println(e.getMessage());
	  }
  	}
}
/*
void inbook() : {Token reference = null, author = null, editor = null, title = null, chapter = null, pages = null, publisher = null, year = null, volume = null,
					number = null, series = null, type = null, address = null, edition = null, month = null, note = null, key = null;}
{
	< OPENBRACES > (reference = <WORD>)? < COMMA >
    (( (<AUTHOR> author = definition()) | (< EDITOR > editor = definition()) ) < COMMA >)?
    (< TITLE > title = definition() < COMMA >)?
    (( (<CHAPTER> chapter = definition()) | (< PAGES > pages = definition()) ) < COMMA >)?
    (< PUBLISHER > publisher = definition() < COMMA >)?
    (< YEAR > year = definition() < COMMA >)?
    ( ((<VOLUME> volume = definition()) | (< NUMBER > number = definition())) < COMMA >)?
    (< SERIES > series = definition() < COMMA >)?
    (< TYPE > type = definition() < COMMA >)?
    (< ADDRESS > address = definition() < COMMA >)?
    (< EDITION > edition = definition() < COMMA >)?
    (< MONTH > month = definition() < COMMA >)?
    (< NOTE > note = definition() < COMMA >)?
    (< KEY > key = definition() < COMMA >)?
    < CLOSEBRACES >
    {
	 try {
	  if (reference == null) throw new ParsingError("[@inbook] : Falta uma chave de citação!");
      if ((author != null || editor != null) && title != null && (chapter != null || pages != null) && publisher != null && year != null)
      {
        Inbook inbk;
		if (author != null)
		{
		  if (chapter != null) inbk = new Inbook(reference.image, "author", author.image, title.image, "chapter", chapter.image, publisher.image, year.image);
		  else inbk = new Inbook(reference.image, "author", author.image, title.image, "pages", pages.image, publisher.image, year.image);
		}
		else
		{
		  if (chapter != null) inbk = new Inbook(reference.image, "editor", editor.image, title.image, "chapter", chapter.image, publisher.image, year.image);
		  else inbk = new Inbook(reference.image, "editor", editor.image, title.image, "pages", pages.image, publisher.image, year.image);
		}

		if (volume != null) inbk.setVolume(volume.image);
		if (number != null) inbk.setNumber(number.image);
		if (series != null) inbk.setSeries(series.image);
		if (type != null) inbk.setType(type.image);
		if (address != null) inbk.setAddress(address.image);
		if (edition != null) inbk.setEdition(edition.image);
		if (month != null) inbk.setMonth(month.image);
		if (note != null) inbk.setNote(note.image);
		if (key != null) inbk.setKey(key.image);
		} else {
		  throw new ParsingError("[@inbook] : Estes campos são obrigatórios: author, title, journal, year, volume.");
		}
	  } catch (ParsingError e) {
	    System.out.println(e.getMessage());
	  }
    }
}

void incollection() : {Token reference = null, author = null, title = null, booktitle = null, publisher = null, year = null, editor = null, volume = null,
						number = null, series = null, type = null, chapter = null, pages = null, address = null, edition = null, month = null, note = null,
							key = null;}
{
	< OPENBRACES > (reference = <WORD>)? < COMMA >
    (<AUTHOR> author = definition()  < COMMA >)?
    (< TITLE > title = definition() < COMMA >)?
    (< BOOKTITLE > booktitle = definition() < COMMA >)?
    (< PUBLISHER > publisher = definition() < COMMA >)?
    (< YEAR > year = definition() < COMMA >)?
    (< EDITOR > editor =definition() < COMMA >)?
    ( ((<VOLUME> volume = definition()) | (< NUMBER > number = definition())) < COMMA >)?
    (< SERIES > series = definition() < COMMA >)?
    (< TYPE > type = definition() < COMMA >)?
    (< CHAPTER > chapter = definition() < COMMA >)?
    (< PAGES > pages = definition() < COMMA >)?
    (< ADDRESS > address= definition() < COMMA >)?
    (< EDITION > edition = definition() < COMMA >)?
    (< MONTH > month = definition() < COMMA >)?
    (< NOTE > note = definition() < COMMA >)?
    (< KEY > key = definition() < COMMA >)?
    < CLOSEBRACES >
    {
	 try {
	  if (reference == null) throw new ParsingError("[@incollection] : Falta uma chave de citação!");
		if (author != null && title != null && booktitle != null && publisher != null && year != null)
		{
			Incollection inc = new Incollection(reference.image, author.image, title.image, booktitle.image, publisher.image, year.image);

			if (editor != null) inc.setEditor(editor.image);
			if (number != null) inc.setNumber(number.image);
			if (volume != null) inc.setVolume(volume.image);
			if (series != null) inc.setSeries(series.image);
			if (type != null) inc.setType(type.image);
			if (chapter != null) inc.setChapter(chapter.image);
			if (pages != null) inc.setPages(pages.image);
			if (address != null) inc.setAddress(address.image);
			if (edition != null) inc.setEdition(edition.image);
			if (month != null) inc.setMonth(month.image);
			if (note != null) inc.setNote(note.image);
			if (key != null) inc.setKey(key.image);
		} else {
		  throw new ParsingError("[@incollection] : Estes campos são obrigatórios: author, title, journal, year, volume.");
		}
	  } catch (ParsingError e) {
	    System.out.println(e.getMessage());
	  }
    }
}

void inproceedings() : {Token reference = null, author = null, title = null, booktitle = null, year = null, editor = null, volume = null, number = null, series = null, pages = null, address = null, month = null, organization = null, publisher = null, note = null, key = null;}
{
	< OPENBRACES > (reference = <WORD>)? < COMMA >
	(< AUTHOR > author = definition() < COMMA >)?
	(< TITLE > title = definition() < COMMA >)?
	(< BOOKTITLE > booktitle = definition() < COMMA >)?
	(< YEAR > year = definition() < COMMA >)?
    (< EDITOR > editor = definition() < COMMA >)?
    ( ((<VOLUME> volume = definition()) | (< NUMBER > number = definition())) < COMMA >)?
    (< SERIES > series = definition() < COMMA >)?
    (< PAGES > pages = definition() < COMMA >)?
    (< ADDRESS > address = definition() < COMMA >)?
    (< MONTH > month = definition() < COMMA >)?
    (< ORGANIZATION > organization = definition() < COMMA >)?
    (< PUBLISHER > publisher = definition() < COMMA >)?
    (< NOTE > note = definition() < COMMA >)?
    (< KEY > key = definition() < COMMA >)?
    < CLOSEBRACES >
	{
	  try {
		if (reference == null) throw new ParsingError("[@inproceedings] : Falta uma chave de citação!");
		if (author != null && title != null && booktitle != null && year != null)
		{
		  Inproceedings inproceedings = new Inproceedings(reference.image, author.image, title.image, booktitle.image, year.image);
		  if (editor != null) inproceedings.setEditor(editor.image);
		  if (volume != null) inproceedings.setVolume(volume.image);
		  if (number != null) inproceedings.setNumber(number.image);
		  if (series != null) inproceedings.setSeries(series.image);
		  if (pages != null) inproceedings.setPages(pages.image);
		  if (address != null) inproceedings.setAddress(address.image);
		  if (month != null) inproceedings.setMonth(month.image);
		  if (organization != null) inproceedings.setOrganization(organization.image);
		  if (publisher != null) inproceedings.setPublisher(publisher.image);
		  if (note != null) inproceedings.setNote(note.image);
		  if (key != null) inproceedings.setKey(key.image);
		} else
		{
		  throw new ParsingError("[@inproceedings] : Estes campos são obrigatórios: author, title, booktitle, year.");
		}
		} catch (ParsingError e)
	  {
	    System.out.println(e.getMessage());
	  }
    }
}
*/
void manual(HashMap<String, String > dados) : {}
{
  {
	  try {
	    String reference = dados.get("reference"), title = dados.get("title");

		if(reference == null || title == null) throw new ParsingError("[@Manual] : Estes campos são obrigatórios: reference, title.");
		else {
		  Manual novoManual = new Manual(reference, title);
		  for (HashMap.Entry<String, String > entry : dados.entrySet()) {
		    if (entry.getKey() == "reference" || entry.getKey() == "title"){}
		    else{
		    switch(entry.getKey())
		    {
		      case "author":
		      	novoManual.setAuthor(entry.getValue());
		      	break;
		      case "organization":
		      	novoManual.setOrganization(entry.getValue());
		      	break;
		      case "address":
		      	novoManual.setAddress(entry.getValue());
		      	break;
		      case "edition":
		      	novoManual.setEdition(entry.getValue());
		      	break;
		      case "month":
		      	novoManual.setMonth(entry.getValue());
		      	break;
		      case "year":
		      	novoManual.setYear(entry.getValue());
		      	break;
		      case "note":
		      	novoManual.setNote(entry.getValue());
		      	break;
		      case "key":
		      	novoManual.setKey(entry.getValue());
		      	break;
		      default:
		      	throw new ParsingError("[@Manual] " + entry.getKey() + " não é um campo válido.");
		      	break;
		    }
		  }
		  }
		  entradas.get("manual").add(novoManual);
		}
	  } catch (ParsingError e)
	  {
	    System.out.println(e.getMessage());
	  }
  	}
}

void mastersthesis(HashMap<String, String > dados) : {}
{
	{
	  try {
	    String reference = dados.get("reference"), title = dados.get("title"), author = dados.get("author"), school = dados.get("school"), year = dados.get("year");

		if(reference == null || title == null || author == null || school == null || year == null) throw new ParsingError("[@MasterThesis] : Estes campos são obrigatórios: reference, title, author, title, school, year.");
		else {
		  Mastersthesis novoMasterThesis = new Mastersthesis(reference, author, title, school, year);
		  for (HashMap.Entry<String, String > entry : dados.entrySet()) {
		    if (entry.getKey() == "reference" || entry.getKey() == "title" || entry.getKey() == "author" || entry.getKey() == "school" || entry.getKey() == "year"){}
		    else{
		    switch(entry.getKey())
		    {
		      case "type":
		      	novoMasterThesis.setType(entry.getValue());
		      	break;
		      case "address":
		      	novoMasterThesis.setAddress(entry.getValue());
		      	break;
		      case "month":
		      	novoMasterThesis.setMonth(entry.getValue());
		      	break;
		      case "note":
		      	novoMasterThesis.setNote(entry.getValue());
		      	break;
		      case "key":
		      	novoMasterThesis.setKey(entry.getValue());
		      	break;
		      default:
		      	throw new ParsingError("[@Manual] " + entry.getKey() + " não é um campo válido.");
		      	break;
		    }
		  }
		  }
		  entradas.get("mastersthesis").add(novoMasterThesis);
		}
	  } catch (ParsingError e)
	  {
	    System.out.println(e.getMessage());
	  }
  	}
}
/*
void misc() : {Token reference = null, author = null, title = null, howpublished = null, month = null, year = null, note = null, key = null;}
{
	< OPENBRACES > (reference = <WORD>)? < COMMA >
    (< AUTHOR > author = definition() < COMMA >)?
    (< TITLE > title = definition() < COMMA >)?
    (< HOWPUBLISHED > howpublished = definition() < COMMA >)?
    (< MONTH > month = definition() < COMMA >)?
    (< YEAR > year = definition() < COMMA >)?
    (< NOTE > note = definition() < COMMA >)?
    (< KEY > key = definition() < COMMA >)?
    < CLOSEBRACES >
	{
	  try {
		if (reference == null) throw new ParsingError("[@misc] : Falta uma chave de citação!");
		if (reference != null)
		{
		  Misc misc = new Misc(reference.image);
		  if (author != null) misc.setAuthor(author.image);
		  if (title != null) misc.setTitle(title.image);
		  if (howpublished != null) misc.setHowpublished(howpublished.image);
		  if (month != null) misc.setMonth(month.image);
		  if (year != null) misc.setYear(year.image);
		  if (note != null) misc.setNote(note.image);
		  if (key != null) misc.setKey(key.image);
		} else
		{
		  throw new ParsingError("[@misc] : Estes campos são obrigatórios: author, title, journal, year, volume.");
		}
	  } catch (ParsingError e)
	  {
	    System.out.println(e.getMessage());
	  }
	}
}

void phdthesis() : {Token reference = null, author = null, title = null, school = null, year = null, type = null, address = null, month = null, note = null, key = null;}
{
	< OPENBRACES > (reference = <WORD>)? < COMMA >
	(< AUTHOR > author = definition() < COMMA >)?
	(< TITLE > title = definition() < COMMA >)?
	(< SCHOOL > school = definition() < COMMA >)?
	(< YEAR > year = definition() < COMMA >)?
	(< TYPE > type = definition() < COMMA > )?
	(< ADDRESS > address = definition() < COMMA > )?
	(< MONTH > month = definition() < COMMA > )?
	(< NOTE > note = definition() < COMMA > )?
	(< KEY > note = definition() < COMMA > )?
	< CLOSEBRACES >
	{
	  try {
		if (reference == null) throw new ParsingError("[@phdthesis] : Falta uma chave de citação!");
		if (author != null && title != null && school != null && year != null)
		{
		  Phdthesis phdthesis = new Phdthesis(reference.image, author.image, title.image, school.image, year.image);
		  if (type != null) phdthesis.setType(type.image);
		  if (address != null) phdthesis.setAddress(address.image);
		  if (month != null) phdthesis.setMonth(month.image);
		  if (note != null) phdthesis.setNote(note.image);
		  if (key != null) phdthesis.setKey(key.image);
		} else
		{
		  throw new ParsingError("[@phdthesis] : Estes campos são obrigatórios: author, title, journal, year, volume.");
		}
	  } catch (ParsingError e)
	  {
	    System.out.println(e.getMessage());
	  }
	}
}

void proceedings() : {Token reference = null, title = null, number = null, year = null, editor = null, volume = null, series = null, address = null, month = null, organization = null, publisher = null, note = null, key = null;}
{
	< OPENBRACES > (reference = <WORD>)? < COMMA >
	(< TITLE > title = definition() < COMMA >)?
	(< YEAR > year = definition() < COMMA >)?
	(< EDITOR > editor = definition() < COMMA >)?
	((< VOLUME > volume = definition() < COMMA >) | (< NUMBER > number = definition() < COMMA >))?
	(< SERIES > series = definition() < COMMA >)?
	(< ADDRESS > address = definition() < COMMA >)?
	(< MONTH > month = definition() < COMMA >)?
	(< ORGANIZATION > organization = definition() < COMMA >)?
	(< PUBLISHER > publisher = definition() < COMMA >)?
	(< NOTE > note = definition() < COMMA >)?
	(< KEY > key = definition() < COMMA >)?
	< CLOSEBRACES >
	{
      try {
		if (reference == null) throw new ParsingError("[@proceedings] : Falta uma chave de citação!");
		if (title != null && year != null)
		{
		  Proceedings proceedings;
		  proceedings = new Proceedings(reference.image, title.image, year.image);
		  if (editor != null) proceedings.setEditor(editor.image);
		  if (number != null) proceedings.setNumber(number.image);
		  if (volume != null) proceedings.setVolume(volume.image);
		  if (series != null) proceedings.setSeries(series.image);
		  if (organization != null) proceedings.setOrganization(organization.image);
		  if (publisher != null) proceedings.setPublisher(publisher.image);
		  if (address != null) proceedings.setAddress(address.image);
		  if (month != null) proceedings.setMonth(month.image);
		  if (note != null) proceedings.setNote(note.image);
		  if (key != null) proceedings.setKey(key.image);
		} else
		{
		  throw new ParsingError("[@proceedings] : Estes campos são obrigatórios: author, title, journal, year, volume.");
		}
	  } catch (ParsingError e)
	  {
	    System.out.println(e.getMessage());
	  }
	}
}

void techreport() : {Token reference = null, author = null, title = null, institution = null, year = null, type = null, number = null, address = null, month = null, note = null, key = null;}
{
	< OPENBRACES > (reference = <WORD>)? < COMMA >
	(< AUTHOR > author = definition() < COMMA >)?
	(< TITLE > title = definition() < COMMA >)?
	(< INSTITUTION > institution = definition() < COMMA >)?
	(< YEAR > year = definition() < COMMA >)?
	(< TYPE > type = definition() < COMMA >)?
	(< NUMBER > number = definition() < COMMA >)?
	(< ADDRESS > address = definition() < COMMA >)?
	(< MONTH > month = definition() < COMMA >)?
	(< NOTE > note = definition() < COMMA >)?
	(< KEY > key = definition() < COMMA >)?
	< CLOSEBRACES >
	{
	  try {
		if (reference == null) throw new ParsingError("[@techreport] : Falta uma chave de citação!");
		if (author != null && title != null && institution != null && year != null)
		{
		  Techreport techreport;
		  techreport = new Techreport(reference.image, author.image, title.image, institution.image, year.image);
		  if (type != null) techreport.setType(type.image);
		  if (number != null) techreport.setNumber(number.image);
		  if (address != null) techreport.setAddress(address.image);
		  if (month != null) techreport.setMonth(month.image);
		  if (note != null) techreport.setNote(note.image);
		  if (key != null) techreport.setKey(key.image);
		} else
		{
		  throw new ParsingError("[@techreport] : Estes campos são obrigatórios: author, title, journal, year, volume.");
		}
	  } catch (ParsingError e)
	  {
	    System.out.println(e.getMessage());
	  }
  	}
}

void unpublished() : {Token reference = null, author = null, title = null, note = null, month = null, year = null, key = null;}
{
	< OPENBRACES > (reference = <WORD>)? < COMMA >
	(< AUTHOR > author = definition() < COMMA >)?
	(< TITLE > title = definition() < COMMA >)?
	(< NOTE > note = definition() < COMMA >)?
	(< MONTH > month = definition() < COMMA >)?
	(< YEAR > year = definition() < COMMA >)?
	(< KEY > key = definition() < COMMA >)?
	< CLOSEBRACES >
	{
	try {
		if (reference == null) throw new ParsingError("[@unpublished] : Falta uma chave de citação!");
		if ( author != null  && title != null && note != null)
		{
		  Unpublished unpublished;
		  unpublished = new Unpublished(reference.image, author.image, title.image, note.image);
		  if (month != null) unpublished.setMonth(month.image);
		  if (year != null) unpublished.setYear(year.image);
		  if (key != null) unpublished.setKey(key.image);
		} else
		{
		  throw new ParsingError("[@unpublished] : Estes campos são obrigatórios: author, title, journal, year, volume.");
		}
	  } catch (ParsingError e)
	  {
	    System.out.println(e.getMessage());
	  }
	}
}
*/